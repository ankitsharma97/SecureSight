# SecureSight: A Modern CCTV Monitoring Dashboard

This project is my take on a comprehensive security dashboard for CCTV surveillance. The goal was to create a tool that's not just functional but also intuitive, allowing security personnel to monitor events in real-time, quickly investigate incidents, and manage everything from a single, clean interface.

## üöÄ What It Does

* **Live Incident Feed:** You get a real-time view of security flags as they happen, pulled from all connected cameras.
* **Interactive 24-Hour Timeline:** I built a visual timeline for each camera that shows the entire day at a glance. Incidents are plotted on the timeline, and I made sure to handle overlapping events so nothing gets missed.
* **One-Click Incident Resolution:** To keep the dashboard clean, operators can mark incidents as "resolved." This uses an optimistic UI update, so it feels instantaneous, while the change is saved in the background.
* **Multi-Camera Support:** The system is designed to handle feeds and data from multiple CCTV cameras.
* **Clean, Responsive UI:** It's built with a modern aesthetic and works smoothly whether you're on a large monitor or a tablet.
* **Always in Sync:** The dashboard keeps the time and incident statuses updated automatically, so you're always looking at the latest information.

## üõ†Ô∏è The Tech Stack

I chose a modern, full-stack TypeScript approach for this project.

### Frontend

* **Next.js 15:** The new App Router is fantastic for this kind of application. Server Components and streaming make the dashboard feel fast and responsive.
* **TypeScript:** A must-have for a project of this scale. It helps catch errors early and makes the code so much easier to maintain.
* **Tailwind CSS & Shadcn/ui:** For the UI, this combination is a dream. It allowed me to build a polished, consistent, and fully responsive interface very quickly.
* **Lucide React:** For a clean and consistent set of icons.

### Backend & Database

* **Next.js API Routes:** Kept the backend simple and co-located with the frontend code. Perfect for building out a quick, serverless API.
* **Prisma & SQLite:** I love Prisma for its type safety‚Äîit basically writes the database queries for you. I used SQLite for the local development database because it's zero-config and just works. No need to spin up a separate database server.

## üìã Getting It Running Locally

1.  **Clone the repo:**
    ```bash
    git clone <repository-url>
    cd security-dashboard
    ```

2.  **Install dependencies:**
    ```bash
    npm install
    ```

3.  **Set up the environment:**
    Create a `.env` file from the example file. This is where you'd put your database connection string.
    ```bash
    cp .env.example .env
    ```

4.  **Get the database ready:**
    Prisma makes this part easy. These commands will set up the database schema and populate it with some sample data.
    ```bash
    # Generate the Prisma client
    npx prisma generate
    
    # Run the initial migration
    npx prisma migrate dev --name init
    
    # Seed the database with sample cameras and incidents
    npm run db:seed
    ```

5.  **Start the server:**
    ```bash
    npm run dev
    ```
    You should now be able to see the dashboard at `http://localhost:3000`.

## üèóÔ∏è Tech Decisions

### Architecture Choices

1. **Next.js App Router**
   - **Why**: Latest Next.js features, improved performance, better SEO
   - **Benefits**: Server components, streaming, improved caching

2. **Prisma ORM**
   - **Why**: Type-safe database operations, excellent developer experience
   - **Benefits**: Auto-generated types, migrations, query optimization

3. **SQLite for Development**
   - **Why**: Zero-configuration, file-based, perfect for development
   - **Benefits**: No server setup, easy backups, portable

4. **Tailwind CSS + Shadcn/ui**
   - **Why**: Rapid UI development, consistent design system
   - **Benefits**: Utility classes, component library, responsive design

5. **TypeScript**
   - **Why**: Type safety across full-stack, better developer experience
   - **Benefits**: Catch errors early, better IDE support, self-documenting code

### Challenges Faced During Development

- **Database Provider Switch (SQLite ‚Üí PostgreSQL)**
  - When moving from local SQLite to production Postgres (Supabase), Prisma migrations and the schema provider had to be updated. Old migrations and migration locks needed to be deleted, and a new migration history started. This is a common real-world pain point when going from local dev to cloud DB.

- **Prisma Client Generation on Vercel**
  - The build failed on Vercel because Prisma Client was not generated by default. Solution: add `prisma generate` to the build script in `package.json` so Vercel always generates the client during deployment.

- **Connection String Confusion**
  - Supabase provides multiple Postgres URLs (pooler, non-pooling, Prisma). For local development and migrations, the direct (5432) connection must be used. For Vercel/serverless, the pooler (6543) URL is required. Using the wrong one led to timeouts and connection errors.

- **Prisma Migrations and Advisory Locks**
  - Sometimes, running migrations on Supabase would hang or fail due to advisory lock timeouts. This was solved by retrying after a few minutes or ensuring no other migration/query was running.

- **Responsive Design Bugs**
  - Making the timeline, incident list, and camera list fully responsive required careful use of Tailwind breakpoints, flexbox, and scroll utilities. Some layouts broke on mobile until min-widths, flex-wrap, and overflow-x-auto were added.

- **API Route Errors**
  - If the database was not migrated or seeded, API routes would return 500 errors. Solution: always run migrations and seed the DB after switching environments.

- **Environment Variable Naming**
  - Prisma expects `DATABASE_URL`, not `POSTGRES_URL`. Using the wrong variable name led to connection failures in production.

These challenges are typical in real-world full-stack projects and were overcome with careful debugging, reading Prisma/Supabase docs, and iterative testing both locally and on Vercel.

### Database Schema Design

Here‚Äôs the basic structure for cameras and incidents in the `schema.prisma` file:

```prisma
model Camera {
  id        String     @id @default(cuid())
  name      String
  location  String
  incidents Incident[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

model Incident {
  id           String   @id @default(cuid())
  cameraId     String
  camera       Camera   @relation(fields: [cameraId], references: [id])
  type         String
  tsStart      DateTime
  tsEnd        DateTime
  thumbnailUrl String?
  resolved     Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}
```

I used `CUID`s for the primary keys because they are short, URL-friendly, and great for avoiding collisions. The timestamps give a clear audit trail, and I made the `thumbnailUrl` optional since not every incident type might have one.

### Frontend Structure

I tried to keep the project organization logical and scalable:

```
app/
‚îú‚îÄ‚îÄ page.tsx              # The main dashboard page
‚îú‚îÄ‚îÄ api/                  # All backend API routes
‚îú‚îÄ‚îÄ layout.tsx            # The root layout for the app
‚îî‚îÄ‚îÄ globals.css           # A few global styles

components/
‚îú‚îÄ‚îÄ ui/                   # Re-usable components from Shadcn/ui
‚îî‚îÄ‚îÄ theme-provider.tsx    # For light/dark mode

hooks/
‚îú‚îÄ‚îÄ use-incidents.ts      # Custom hook for fetching incident data
‚îî‚îÄ‚îÄ use-cameras.ts        # Custom hook for camera data

lib/
‚îú‚îÄ‚îÄ prisma.ts             # The Prisma client instance
‚îî‚îÄ‚îÄ utils.ts              # Helper functions
```

## üîÆ If I Had More Time...

This is a solid foundation, but there's always more to do! Here's where I'd take it next.

### Short-Term (Next couple of weeks)

* **Authentication:** Definitely the top priority. I'd add JWT-based auth with roles like Admin and Operator.
* **Live Video Feeds:** Integrate WebRTC to stream live video directly into the dashboard.
* **Real-time Notifications:** Use WebSockets to push updates to the UI instantly, rather than relying on polling. This would also power toast notifications for critical incidents.

### Medium-Term (1-2 months)

* **AI-Powered Detection:** This is where it gets really interesting. I'd love to integrate a computer vision model to automatically detect and classify threats, moving beyond simple motion alerts.
* **Mobile App:** A simple React Native app for on-the-go monitoring and incident reporting would be a huge win.
* **Analytics Dashboard:** Add some charts and graphs to visualize incident trends over time, helping to identify problem areas.

### Long-Term Vision

* **IoT Integration:** Connect to other smart devices like door locks or sensors. Imagine being able to lock down an area directly from the incident view.
* **Advanced Search:** Implement a powerful search feature to quickly find past incidents by date, location, type, etc.
* **Cloud Deployment:** Architect the application for the cloud using a microservices approach and Kubernetes for auto-scaling.

## üìù API Docs

Here's a quick overview of the available API endpoints.

#### `GET /api/incidents`

Fetches a list of incidents. Can be filtered by resolution status.

**Query Params:**

* `resolved` (boolean): Set to `true` or `false` to filter incidents.

**Example Response:**

```json
[
  {
    "id": "clxql0v9v0000z49v5e3g6a2b",
    "cameraId": "clxql0v9s0000z49v1a2b3c4d",
    "type": "Motion Detected",
    "tsStart": "2025-07-24T10:30:00Z",
    "tsEnd": "2025-07-24T10:32:00Z",
    "thumbnailUrl": "/thumbnails/incident-1.jpg",
    "resolved": false,
    "camera": {
      "id": "clxql0v9s0000z49v1a2b3c4d",
      "name": "CAM-01",
      "location": "Main Entrance"
    }
  }
]
```

#### `PATCH /api/incidents/:id/resolve`

Toggles the `resolved` status of a single incident.

**Example Response:**

```json
{
  "id": "clxql0v9v0000z49v5e3g6a2b",
  "resolved": true,
  "camera": {
    "id": "clxql0v9s0000z49v1a2b3c4d",
    "name": "CAM-01",
    "location": "Main Entrance"
  }
}
```

#### `GET /api/cameras`

Fetches a list of all cameras and their most recent incidents.

**Example Response:**

```json
[
  {
    "id": "clxql0v9s0000z49v1a2b3c4d",
    "name": "CAM-01",
    "location": "Main Entrance",
    "incidents": [
      {
        "id": "clxql0v9v0000z49v5e3g6a2b",
        "type": "Motion Detected",
        "tsStart": "2025-07-24T10:30:00Z",
        "tsEnd": "2025-07-24T10:32:00Z",
        "resolved": false
      }
    ]
  }
]
```